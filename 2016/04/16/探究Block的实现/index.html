
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>探究Block的实现 | Helly的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在开发过程中，我们会经常使用到Block，今天就让我们来探究一下Block的实现。
一、NSConcreteGlobalBlock类型的block的实现首先我们写一个最简单的Block，然后用clang -rewrite-objc命令将其重写成C++的实现。
123456789101112#import &amp;lt;Foundation/Foundation.h&amp;gt;int main(int arg">
<meta property="og:type" content="article">
<meta property="og:title" content="探究Block的实现">
<meta property="og:url" content="http://helly1024.github.io/2016/04/16/探究Block的实现/index.html">
<meta property="og:site_name" content="Helly的技术博客">
<meta property="og:description" content="在开发过程中，我们会经常使用到Block，今天就让我们来探究一下Block的实现。
一、NSConcreteGlobalBlock类型的block的实现首先我们写一个最简单的Block，然后用clang -rewrite-objc命令将其重写成C++的实现。
123456789101112#import &amp;lt;Foundation/Foundation.h&amp;gt;int main(int arg">
<meta property="og:updated_time" content="2016-04-15T16:16:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="探究Block的实现">
<meta name="twitter:description" content="在开发过程中，我们会经常使用到Block，今天就让我们来探究一下Block的实现。
一、NSConcreteGlobalBlock类型的block的实现首先我们写一个最简单的Block，然后用clang -rewrite-objc命令将其重写成C++的实现。
123456789101112#import &amp;lt;Foundation/Foundation.h&amp;gt;int main(int arg">
  
    <link rel="alternative" href="/atom.xml" title="Helly的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <link href="favicon.ico" type="image/x-icon" rel="icon"/>
<header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Helly的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">纸上得来终觉浅，绝知此事要躬行。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="helly1024.github.io">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-探究Block的实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/16/探究Block的实现/" class="article-date">
  <time datetime="2016-04-15T16:14:57.000Z" itemprop="datePublished">2016-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/源码阅读/">源码阅读</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      探究Block的实现
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在开发过程中，我们会经常使用到Block，今天就让我们来探究一下Block的实现。</p>
<h2 id="一、NSConcreteGlobalBlock类型的block的实现"><a href="#一、NSConcreteGlobalBlock类型的block的实现" class="headerlink" title="一、NSConcreteGlobalBlock类型的block的实现"></a>一、NSConcreteGlobalBlock类型的block的实现</h2><p>首先我们写一个最简单的Block，然后用<code>clang -rewrite-objc</code>命令将其重写成C++的实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^printBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    printBlock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过<code>clang -rewrite-objc</code>命令将变换成如下形式（省略了无关代码）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*printBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)printBlock)-&gt;FuncPtr)((__block_impl *)printBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们从两段代码相似度最高的地方入手，可以发现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">    printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>被转换成了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到Block花括号中的代码实际上是作为一个C语言的函数来处理的。多做几个实验可以发现，该函数名的前缀是Block所在的函数名（这里是<code>main</code>），后缀是该Block在所在函数中出现的顺序值（这里是<code>0</code>）。<br>该函数的参数<code>__cself</code>是一个指向结构体<code>__main_block_impl_0</code>的指针。该结构体的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体看起来有些复杂，但是当我们先除去它的构造函数并展开它嵌套的两个结构体，就会发现它跟常规的结构体是一样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;    <span class="comment">// 指向该对象所属的类</span></span><br><span class="line">  <span class="keyword">int</span> Flags;    <span class="comment">// 用于按位表示一些block的附加信息</span></span><br><span class="line">  <span class="keyword">int</span> Reserved;   <span class="comment">// 保留字段</span></span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;    <span class="comment">// 指向实现Block的函数的地址（这里即函数__main_block_func_0的地址）</span></span><br><span class="line">  size_t reserved;    <span class="comment">// 保留字段</span></span><br><span class="line">  size_t Block_size;    <span class="comment">// Block占用内存空间的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来看看结构体<code>__main_block_impl_0</code>的构造函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">  impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">  impl.Flags = flags;</span><br><span class="line">  impl.FuncPtr = fp;</span><br><span class="line">  Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是在<code>int main(int argc, const char * argv[])</code>函数中调用的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*printBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>
<p>这段代码进行了很多转换，所以看起来比较复杂，下面我们来一步步地分析：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>
<p>首先是调用<code>__main_block_impl_0</code>结构体的构造函数生成了一个<code>__main_block_impl_0</code>结构体实例；<br>然后使用取地址符（&amp;）获取该实例的地址；<br>最后将该地址赋值给<code>__main_block_impl_0</code>结构体指针<code>printBlock</code>。</p>
<p>上面的代码也可以转换成如下形式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 tmp = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 *printBlock = &amp;tmp;</span><br></pre></td></tr></table></figure>
<p>上述代码对应最初源码中的这一段：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^printBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">  printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们再来看构造函数的参数，在调用构造函数时传递了两个参数：指向<code>__main_block_func_0</code>的函数指针和<code>__main_block_desc_0</code>类型的结构体<code>__main_block_desc_0_DATA</code>的地址。在函数的实现部分则将这两个参数分别赋值给<code>__main_block_impl_0</code>类型结构体的成员变量<code>FuncPtr</code>和<code>desc</code>，用以进行结构体的初始化。现在就不难理解<code>__main_block_func_0(struct __main_block_impl_0 *__cself)</code>函数中的参数<code>__cself</code>了：它指向了将该函数指针作为成员变量的<code>__main_block_impl_0</code>结构体的实例，相当于C++实例方法中指向实例自身的变量this，或者是OC实例方法中指向对象自身的变量self。</p>
<p>接下来在最初源码中调用了该Block：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printBlock();</span><br></pre></td></tr></table></figure>
<p>对应转换后的这行代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)printBlock)-&gt;FuncPtr)((__block_impl *)printBlock);</span><br></pre></td></tr></table></figure>
<p>去掉转换部分是这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（*printBlock-&gt;FuncPtr)(printBlock);</span><br></pre></td></tr></table></figure>
<p>其实就是使用函数指针来调用函数，后面的括号中的<code>printBlock</code>是参数，这也印证了上面对<code>__cself</code>的解释。</p>
<p>现在可以确定，Block的实际上就是一个结构体，使用Block就是通过结构体中的成员变量，指向<code>__main_block_func_0</code>函数的函数指针<code>FuncPtr</code>来调用<code>__main_block_func_0</code>函数。</p>
<p>在<code>__main_block_impl_0</code>结构体中我们还有一个成员变量<code>isa</code>一直没有说，它代表了Block的类型，有以下三种类型：</p>
<ul>
<li><code>_NSConcreteGlobalBlock</code>，全局静态Block，它不会访问任何外部变量，我们前面研究的那个Block就是全局Block。虽然它的<code>isa</code>指针指向的是<code>_NSConcreteStackBlock</code>，但这是由于我们使用clang命令将OC的实现转换成C++的的实现方式和LLVM不同。实际上在代码运行过程中<code>po</code>这个Block就会发现它是<code>_NSConcreteGlobalBlock</code>；</li>
<li><code>_NSConcreteStackBlock</code>，保存在栈中的Block，只存在于某个固定的作用域（如函数）当中，当超出这个作用域Block就会被销毁；</li>
<li><code>_NSConcreteMallocBlock</code>，保存在堆中的Block，这种Block无法直接创建，是通过<code>_NSConcreteStackBlock</code>拷贝到堆中而来，要在多个地方使用同一个栈上的Block时，就需要将Block从栈上拷贝到堆中，以防止Block在栈中被销毁。</li>
</ul>
<p>另外，ARC对Block也有影响。在开启ARC的情况下，只会有<code>_NSConcreteGlobalBlock</code>和<code>_NSConcreteMallocBlock</code>，<code>_NSConcreteStackBlock</code>将会被<code>_NSConcreteMallocBlock</code>替代。</p>
<h2 id="二、NSConcreteStackBlock类型的block的实现"><a href="#二、NSConcreteStackBlock类型的block的实现" class="headerlink" title="二、NSConcreteStackBlock类型的block的实现"></a>二、NSConcreteStackBlock类型的block的实现</h2><p>接下来我们看看<code>_NSConcreteStackBlock</code>的实现方式和<code>_NSConcreteGlobalBlock</code>有什么不同。这两种Block的区别在于<code>_NSConcreteStackBlock</code>将会捕捉外部变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;s</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">void</span> (^printBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">"Hello, World!\n%d\n"</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    printBlock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码通过<code>clang -rewrite-objc</code>命令转换后是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> _a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        printf(<span class="string">"Hello, World!\n%d\n"</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">void</span> (*printBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)printBlock)-&gt;FuncPtr)((__block_impl *)printBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它与<code>_NSConcreteGlobalBlock</code>源码不同的地方在于：</p>
<ol>
<li>在实现Block的结构体<code>__main_block_impl_0</code>中多出了一个成员变量<code>int a</code>；</li>
<li>在<code>__main_block_func_0</code>函数中多了一行代码<code>int a = __cself-&gt;a;</code>;</li>
<li>在<code>main</code>函数调用<code>__main_block_impl_0</code>的构造函数时增加了一个参数，<code>main</code>函数中的局部变量<code>a</code>。</li>
</ol>
<p>现在Block捕获外部变量的过程就可以理解了：外部变量的值作为参数传递给<code>__main_block_impl_0</code>结构体的构造函数，并在结构体中添加一个同名的成员变量来保存。在执行block花括号中的代码的过程其实就是调用<code>__main_block_func_0</code>函数，这时<code>__main_block_func_0</code>函数通过参数<code>__cself</code>就可以获取外部变量的值。在这个过程中传递的是外部变量的值，这也是没有用<code>__block</code>来修饰的外部变量不能在Block中修改的原因。</p>
<h2 id="三、使用-block修饰的外部变量的实现"><a href="#三、使用-block修饰的外部变量的实现" class="headerlink" title="三、使用__block修饰的外部变量的实现"></a>三、使用<code>__block</code>修饰的外部变量的实现</h2><p>如果使用了<code>__block</code>修饰外部变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;s</span><br><span class="line">    __block <span class="keyword">int</span> a = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">void</span> (^printBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">"Hello, World!\n%d\n"</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    printBlock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那转换成C++后的源码又将大不相同：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_a_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        printf(<span class="string">"Hello, World!\n%d\n"</span>,(a-&gt;__forwarding-&gt;a));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_a_0 a = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_a_0), <span class="number">1024</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*printBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    (a.__forwarding-&gt;a) += <span class="number">1</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)printBlock)-&gt;FuncPtr)((__block_impl *)printBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与没有使用<code>__block</code>修饰的外部变量的源码不同的地方是<code>__main_block_impl_0</code>结构体中的<code>int a;</code>变成了<code>__Block_byref_a_0 *a;</code>,一个指向<code>__Block_byref_a_0</code>结构体的指针。在<code>main</code>函数中声明了一个<code>__Block_byref_a_0</code>结构体变量a并为它赋值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_a_0 a = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_a_0), <span class="number">1024</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>与它对应的OC代码是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> a = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>带有<code>__block</code>修饰的局部变量a转换成了一个<code>__Block_byref_a_0</code>类型的结构体变量<code>a</code>，结构体中保存了该结构体变量的地址和变量<code>a</code>的值。下一行代码同样是通过构造函数使<code>__main_block_impl_0</code>结构体变量保存了结构体变量<code>a</code>的地址。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*printBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="number">570425344</span>));</span><br></pre></td></tr></table></figure>
<p>这样,在<code>__main_block_func_0</code>函数中就可以获取到原来局部变量<code>a</code>的值了。同时在Block外，<code>main</code>函数中访问局部变量<code>a</code>的值得方式也发生了改变。它同<code>__main_block_func_0</code>函数中一样，同样是通过<code>__Block_byref_a_0</code>结构体变量中指向自己的结构体指针来访问的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a.__forwarding-&gt;a) += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>总结成一句话：使用<code>__block</code>修饰的外部变量在Block中能被修改是因为Block是通过指针访问的，而没有使用<code>__block</code>修饰的外部变量，仅仅是将它的值拷贝到了Block中。</p>
<h2 id="四、NSConcreteMallocBlock类型的block的实现"><a href="#四、NSConcreteMallocBlock类型的block的实现" class="headerlink" title="四、NSConcreteMallocBlock类型的block的实现"></a>四、NSConcreteMallocBlock类型的block的实现</h2><p>另外，在<code>__main_block_desc_0</code>结构体中还多了两个成员变量：指向<code>__main_block_copy_0</code>函数的函数指针<code>copy</code>和指向<code>__main_block_dispose_0</code>函数的函数指针<code>dispose</code>。根据函数名和实现可以确定它们跟Block的拷贝有关，那就先来看看将Block从栈上拷贝到堆中是如何实现的。拷贝操作需要调用<code>Block_copy()</code>函数，在Block.h文件中可以找到它的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define Block_copy(...) ((__typeof(__VA_ARGS__))_Block_copy((const void *)(__VA_ARGS__)))</span></span><br><span class="line"></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *aBlock)</span><br><span class="line">    __OSX_<span class="built_in">AVAILABLE_STARTING</span>(__MAC_10_6, __IPHONE_3_2);</span><br></pre></td></tr></table></figure>
<p><code>Block_copy</code>是一个宏定义，它将参数进行了强制类型转换然后传给了<code>_Block_copy</code>函数。在<a href="http://llvm.org/releases/3.8.0/compiler-rt-3.8.0.src.tar.xz" target="_blank" rel="external">LLVM源码</a>的runtime.c文件中可以看到它的实现。这个函数的作用是在堆中创建一个Block的拷贝，或者为一个已经在堆中的Block添加引用。需要注意的是它必须和<code>Block_release</code>成对出现以恢复内存。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="keyword">return</span> _Block_copy_internal(arg, WANTS_ONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_Block_copy</code>函数又将<code>Block_copy</code>函数传入的Block和<code>WANTS_ONE</code>作为参数调用了<code>_Block_copy_internal</code>函数。在的runtime.c的286~355行可以找到<code>_Block_copy_internal</code>的实现（删除了垃圾回收相关的代码并添加注释）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copy, or bump refcount, of a block.  If really copying, call the copy helper if present. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *_Block_copy_internal(<span class="keyword">const</span> <span class="keyword">void</span> *arg, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_layout *aBlock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断如果参数为`NULL`则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将参数从指针还原成Block结构体</span></span><br><span class="line">    aBlock = (<span class="keyword">struct</span> Block_layout *)arg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果flags中包含BLOCK_NEEDS_FREE，则说明这个Block在堆上，于是通过latching_incr_int函数将引用计数加1，这里可以判断出，Block结构体的flags中包含了Block类型和引用计数等信息</span></span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果这是一个全局Block，就什么也不做</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代码运行到这可以确定这是一个在栈上的Block了，于是在堆上开辟一块和Block对应大小的空间，失败则返回0</span></span><br><span class="line">        <span class="keyword">struct</span> Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将原来的的Block按位拷贝到新开辟的内存空间</span></span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改堆上Block的flags，重置Block的类型信息和引用计数</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);</span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将Block的isa指针设置为_NSConcreteMallocBlock</span></span><br><span class="line">        result-&gt;isa = _<span class="built_in">NSConcreteMallocBlock</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果存在，则调用Block的辅助拷贝函数</span></span><br><span class="line">        <span class="keyword">if</span> (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            (*aBlock-&gt;descriptor-&gt;<span class="keyword">copy</span>)(result, aBlock); <span class="comment">// do fixup</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码的最后判断了Block的结构体实例中是否存在一个<code>copy</code>函数，如果存在，则会以指向堆上Block结构体实例的指针和指向栈上结构体实例的指针为参数调用<code>copy</code>函数。这个<code>copy</code>函数就是我们之前发现在<code>__main_block_desc_0</code>结构体中多出来的两个成员变量中的一个。下面来看看<code>copy</code>函数的实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, </span><br><span class="line">                                <span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>__main_block_copy_0</code>函数只是简单的调用了<code>_Block_object_assign</code>。根据在<code>_Block_copy_internal</code>函数的源码调用<code>copy</code>时传的传递的参数可知<code>_Block_object_assign</code>的参数分别是堆上Block结构体实例中保存外部变量的成员变量的地址和栈上Block结构体实例中保存的外部变量和一个用来表示外部变量类型的常数。在runtime.c文件中我们同样可以找到<code>_Block_object_assign</code>函数的实现(省略了无关代码)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Block_object_assign(<span class="keyword">void</span> *destAddr, <span class="keyword">const</span> <span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  &#123;</span><br><span class="line">        _Block_byref_assign_copy(destAddr, object, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中调用了<code>_Block_byref_assign_copy</code>函数。这个函数的作用是将栈上<code>__block</code>修饰的变量（也就是<code>__Block_byref_a_0</code>结构体实例）拷贝到堆中。以下是它的实现（删除了垃圾回收相关代码）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _Block_byref_assign_copy(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *arg, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_byref **destp = (<span class="keyword">struct</span> Block_byref **)dest;</span><br><span class="line">    <span class="keyword">struct</span> Block_byref *src = (<span class="keyword">struct</span> Block_byref *)arg;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在堆中开辟一块与传入的Block_byref结构体相同大小的内存空间</span></span><br><span class="line">        <span class="keyword">struct</span> Block_byref *<span class="keyword">copy</span> = (<span class="keyword">struct</span> Block_byref *)_Block_allocator(src-&gt;size, <span class="literal">false</span>, isWeak);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置堆中Block_byref结构体的flags的值</span></span><br><span class="line">        <span class="keyword">copy</span>-&gt;flags = src-&gt;flags | _Byref_flag_initial_value; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使forwarding指针指向自己</span></span><br><span class="line">        <span class="keyword">copy</span>-&gt;forwarding = <span class="keyword">copy</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置栈上的Block_byref结构体中的forwarding指针指向堆中的Block_byref结构体，这样无论通过哪个结构体的forwarding指针，访问到的都是堆上的Block_byref结构体</span></span><br><span class="line">        src-&gt;forwarding = <span class="keyword">copy</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置堆中Block_byref结构体的size的值</span></span><br><span class="line">        <span class="keyword">copy</span>-&gt;size = src-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已经在堆中，增加引用计数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使通过参数传进来的结构体指针指向将堆上Block_byref结构体，即持有`__block`修饰的变量</span></span><br><span class="line">    _Block_assign(src-&gt;forwarding, (<span class="keyword">void</span> **)destp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上文中我们提到过<code>Block_copy</code>必须和<code>Block_release</code>成对出现以恢复内存。那么<code>Block_release</code>的作用就不言而喻，它在我们不再使用Block的时候将其释放，同样在<code>Block_release</code>中也会调用<code>__main_block_desc_0</code>结构体中的<code>dispose</code>函数，用来释放被Block持有的<code>__block</code>修饰的变量。</p>
<p>通过上面的分析可以知道，在Block从栈上拷贝到堆中的过程中，Block中使用的<code>__block变量</code>同样会被从栈上拷贝到堆中。这点并不难理解，当需要将Block拷贝到堆上时，很多时候是因为要在其他地方使用这个Block，而此时很有可能已经超出了<code>__block变量</code>的作用域。为了避免出现这样的问题，将<code>__block变量</code>拷贝到堆中并由Block持有也是顺理成章的事了。</p>
<h2 id="五、Block的循环引用"><a href="#五、Block的循环引用" class="headerlink" title="五、Block的循环引用"></a>五、Block的循环引用</h2><p>堆上的Block不光会持有<code>__block变量</code>，同样也会持有在Block中使用的没有用<code>__block</code>修饰的外部变量，这也是Block会出现循环引用问题的根源。因此在编码过程中，我们要避免出现Block和Block中使用的外部变量相互强引用的情况（这里所说的外部变量默认为是由<code>__strong</code>修饰）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^printBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者，在合适的时机打断它们之间的相互强引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block blockSelf = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^printBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, blockSelf);</span><br><span class="line">    blockSelf = <span class="literal">nil</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是这种方法有一个缺点，那就是：为了防止循环引用，必须执行Block。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://helly1024.github.io/2016/04/16/探究Block的实现/" data-id="cin1x3cmw0005gvsxzh7fhurm" class="article-share-link" data-share="baidu" data-title="探究Block的实现">分享到</a>
      

      
        <a href="http://helly1024.github.io/2016/04/16/探究Block的实现/#ds-thread" class="article-comment-link">文章评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Block/">Block</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/04/05/AutoreleasePool的原理和实现/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">AutoreleasePool的原理和实现</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2016/04/16/探究Block的实现/" data-title="探究Block的实现" data-url="http://helly1024.github.io/2016/04/16/探究Block的实现/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码阅读/">源码阅读</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AutoreleasePool/">AutoreleasePool</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Block/">Block</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Core-Animation/">Core Animation</a><span class="tag-list-count">5</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/16/探究Block的实现/">探究Block的实现</a>
          </li>
        
          <li>
            <a href="/2016/04/05/AutoreleasePool的原理和实现/">AutoreleasePool的原理和实现</a>
          </li>
        
          <li>
            <a href="/2015/08/10/iOS Core Animation Advanced Techniques学习笔记（5）/">iOS Core Animation Advanced Techniques学习笔记（5）</a>
          </li>
        
          <li>
            <a href="/2015/08/10/iOS Core Animation Advanced Techniques学习笔记（2）/">iOS Core Animation Advanced Techniques学习笔记（2）</a>
          </li>
        
          <li>
            <a href="/2015/08/10/iOS Core Animation Advanced Techniques学习笔记（4）/">iOS Core Animation Advanced Techniques学习笔记（4）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Helly<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"helly1024"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>



<script src="/js/script.js"></script>

</div>
</body>
</html>
